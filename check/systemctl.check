#!/usr/bin/env bash
#
# Copyright (C) 2017-2026  Christian Garbs <mitch@cgarbs.de>
# Licensed under GNU GPL v3 or later.
#
# This file is part of nomd.
#
# nomd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# nomd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with nomd.  If not, see <http://www.gnu.org/licenses/>.
#

##SHELLDEP cut
##SHELLDEP grep
##SHELLDEP systemctl

check_systemctl()
##CHECKDSC check systemctl for failed units
#
##PARMNAME $1
##PARMDESC 'system' or 'user' to select which units to check
##PARMDFLT system
{
    # receive parameters and set defaults
    local what=${1:-system}

    # spawn subshell because environment might be changed
    (

	# select what to do
	local params=(--full)
	case "$what" in
	    system)
	    ;;

	    user)
		ensure_dbus_socket_env_is_set systemctl-user

		params+=(--user)
		;;

	    *)
		echo "C:systemctl:configuration error - undefined value \`$what' for \$1"
		exit
		;;
	esac

	# read output into array
	local -a units
	readarray -t units < <(systemctl "${params[@]}" | grep failed | cut -d\  -f 2)

	# output
	if [ ${#units[@]} -gt 0 ]; then
	    local unit
	    for unit in "${units[@]}"; do
		echo "C:systemctl-$what:failed unit $unit"
	    done
	else
	    echo "I:systemctl-$what:no failed units"
	fi

    )
}

check_active_system_unit()
##CHECKDSC check systemctl for an active global unit
#
##PARMNAME $1
##PARMDESC the unit to check
##PARMDFLT default.target
{
    # receive parameters and set defaults
    local unit="${1:-default.target}"

    # check and output
    if systemctl is-active "$unit" >/dev/null; then
	echo "I:active_unit:unit $unit is active"
    else
	echo "C:active_unit:unit $unit is inactive"
    fi
}

check_active_user_unit()
##CHECKDSC check systemctl for an active unit of the current user
#
##PARMNAME $1
##PARMDESC the unit to check
##PARMDFLT default.target
{
    # receive parameters and set defaults
    local unit=${1:-default.target}

    # spawn subshell because environment is changed
    (
	ensure_dbus_socket_env_is_set active_user_unit

	# check and output
	if systemctl --user is-active "$unit" >/dev/null; then
	    echo "I:active_user_unit:user unit $unit is active"
	else
	    echo "C:active_user_unit:user unit $unit is inactive"
	fi
    )
}

ensure_dbus_socket_env_is_set()
{
    local check_name=$1

    if [ -z "$DBUS_SESSION_BUS_ADDRESS" ]; then
	# try to find dbus session bus
	local dbus_socket=/run/user/$UID/bus
	if [ ! -e "$dbus_socket" ]; then
	    echo "W:${check_name}:no connection to user instance: $dbus_socket is missing"
	    exit
	fi
	if [ ! -r "$dbus_socket" ]; then
	    echo "W:${check_name}:no connection to user instance: $dbus_socket is not readable"
	    exit
	fi
	if [ ! -w "$dbus_socket" ]; then
	    echo "W:${check_name}:no connection to user instance: $dbus_socket is not writable"
	    exit
	fi
	export DBUS_SESSION_BUS_ADDRESS="unix:path=$dbus_socket"
    fi
}
